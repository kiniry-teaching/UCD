using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.ComponentModel;
using System.Drawing;
using System.Text.RegularExpressions;

namespace Shed
{

	public enum TypesOfShape
	{
		Movement,
		Speed,
		Acceleration
	}

	public class Shape
	{
		protected TreeNode _node;
		protected Rectangle _windowPosition;
		protected frmShape _form;
		protected TypesOfShape _type;
		protected int _width;
		protected int _height;
		protected int _hBound;
		protected int _vBound;
		protected float _dampen;
		protected bool _anystart = false;
		protected bool _reverse = false;
		protected Zones _zones;
		protected Pixels _pixels;
		protected uint _sid;
		public uint UseSID;
		
		public Shape(TreeNode node)
		{
			_node = node;
			_node.Tag = this;
			_width = 32;
			_height = 32;
			_hBound = 4;
			_vBound = 4;
			_type = TypesOfShape.Movement;
			_zones = new Zones();
			_sid = 0;
			_pixels = new Pixels(this);
			_pixels.CreatePixels(_width, _height);
		}

		[BrowsableAttribute(false)]
		public TreeNode Node
		{
			get { return _node; }
		}
		
		[BrowsableAttribute(false)]
		public frmShape Form
		{
			get { return _form; }
			set { _form = value; }
		}
		
		[BrowsableAttribute(false)]
		public Rectangle WindowPosition
		{
			get { return _windowPosition; }
			set { _windowPosition = value; }
		}

		[BrowsableAttribute(false)]
		public Pixels Pixels
		{
			get { return _pixels; }
		}

		[DefaultValueAttribute("SID_*"),
		 DescriptionAttribute("Enum name for automatically generated header"),
		 CategoryAttribute("Details")]
		public string Name
		{
			get { return _node.Text; }
			set
			{
				if(value.IndexOf('*') == -1)
				{

					Regex rx = new Regex("^[a-zA-Z_][a-zA-Z0-9_\\*]*$");
					if(rx.IsMatch(value) == false)
						throw new Exception("Invalid name - must start with a-z or _ and follow with a-z, _, or 0-9");
				
					foreach(TreeNode node in Node.TreeView.Nodes)
						if(NameUsed(value, node) == true)
							throw new Exception("Name already in use");

				}

				_node.Text = value;
				if(_form != null)
					_form.Shape = this;
			}
		}

		private bool NameUsed(string v, TreeNode node)
		{
			Shape shape;

			if(node.Tag is Shape)
			{
				shape = (Shape)node.Tag;
				if(shape.Name == v)
					return true;
			}

			foreach(TreeNode n in node.Nodes)
				if(NameUsed(v, n) == true)
					return true;

			return false;

		}

		[DefaultValueAttribute(0),
		 DescriptionAttribute("Shape identifier. If 0, this will be automatically generated by incrementing number"),
		 CategoryAttribute("Details")]
		public uint SID
		{
			get { return _sid; }
			set
			{
				if(value != 0)
					foreach(TreeNode node in Node.TreeView.Nodes)
						if(SIDUsed(value, node) == true)
							throw new Exception("Value already in use");
				_sid = value;
			}
		}

		private bool SIDUsed(uint v, TreeNode node)
		{
			Shape shape;

			if(node.Tag is Shape)
			{
				shape = (Shape)node.Tag;
				if(shape.SID == v)
					return true;
			}

			foreach(TreeNode n in node.Nodes)
				if(SIDUsed(v, n) == true)
					return true;

			return false;

		}

		[DefaultValueAttribute(TypesOfShape.Movement),
		 DescriptionAttribute("Does this shape describe a movement, speed, or acceleration"),
		 CategoryAttribute("Details")]
		public TypesOfShape Type
		{
			get { return _type; }
			set
			{
				if(Node.Nodes.Count != 0 && value != TypesOfShape.Movement)
					throw new Exception("Type must be Movement if Shape has sub shapes");
				if(Node.Parent != null && Node.Parent.Parent != null)
					if(value != TypesOfShape.Speed && value != TypesOfShape.Acceleration)
						throw new Exception("Sub shapes must be type Speed or Acceleration");
				_type = value;
			}
		}

		[DefaultValueAttribute(0.0f),
		 DescriptionAttribute("Dampen intensity of near pixels glow"),
		 CategoryAttribute("Details")]
		public float Dampen
		{
			get { return _dampen; }
			set
			{
				if(value < 0.0f || value > 1.0f)
					throw new Exception("Out of range, must be between 0 and 1");
				_dampen = value;
				if(_form != null)
					_form.trkWeight.Value = (int)(_dampen * _form.trkWeight.Maximum);
			}
		}

		[DefaultValueAttribute(32),
		 DescriptionAttribute("Number of vertical cells"),
		 CategoryAttribute("Grid")]
		public int Width
		{
			get { return _width; }
			set
			{
				if(value < 16)
					throw new Exception("Too small");
				_pixels.CreatePixels(value, _height);
				_width = value;
				if(_form != null)
					_form.Shape = this;
			}
		}

		[DefaultValueAttribute(32),
		 DescriptionAttribute("Number of horizontal cells"),
		 CategoryAttribute("Grid")]
		public int Height
		{
			get { return _height; }
			set
			{
				if(value < 16)
					throw new Exception("Too small");
				_pixels.CreatePixels(_width, value);
				_height = value;
				if(_form != null)
					_form.Shape = this;
			}
		}

		[DefaultValueAttribute(4),
		 DescriptionAttribute("Horizontal Boundary. Movement is scaled to fit this"),
		 CategoryAttribute("Grid")]
		public int HBound
		{
			get { return _hBound; }
			set
			{
				if(value < 0)
					throw new Exception("Too small");
				if(value > _width / 2 - 1)
					throw new Exception("Too big");
				_hBound = value;
				if(_form != null)
					_form.Shape = this;
			}
		}

		[DefaultValueAttribute(4),
		 DescriptionAttribute("Vertical Boundary. Movement is scaled to fit this"),
		 CategoryAttribute("Grid")]
		public int VBound
		{
			get { return _vBound; }
			set
			{
				if(value < 0)
					throw new Exception("Too small");
				if(value > _height / 2 - 1)
					throw new Exception("Too big");
				_vBound = value;
				if(_form != null)
					_form.Shape = this;
			}
		}

		[DefaultValueAttribute(false),
		 DescriptionAttribute("Is a gesture allowed to go through the zones in reverse (Allows the shape to test with the enter/exit angles/arcs swapped (radius remains the same))"),
		 CategoryAttribute("Zone")]
		public bool ZoneReverse
		{
			get { return _reverse; }
			set { _reverse = value; }
		}

		[DefaultValueAttribute(false),
		 DescriptionAttribute("Is a gesture allowed to start from any zone, or can it only start from the first one"),
		 CategoryAttribute("Zone")]
		public bool ZoneAnyStart
		{
			get { return _anystart; }
			set { _anystart = value; }
		}

		[TypeConverter(typeof(ExpandableObjectConverter)),
		 DescriptionAttribute("Zones"),
		 CategoryAttribute("Zone")]
		public Zones Zones
		{
			get { return _zones; }
		}

		public float CalculateDimmingWeight()
		{	float dim;
			float maxdim = 1.0f;

			for(int y = 0; y < _height; y++)
			for(int x = 0; x < _width; x++)
				if((dim = _pixels.Pixel[x, y].CalculateWeight(1.0f, float.MinValue, float.MaxValue)) > maxdim)
					maxdim = dim;

			return 1 - (1 - (1 / maxdim)) * (float)_dampen;

		}

	}

}
