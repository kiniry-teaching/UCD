#ifndef __INTERPRETER_RECORDING_H__
#define __INTERPRETER_RECORDING_H__

#ifdef WIN32
#	pragma warning(disable: 4786)
#endif
#include <vector>
#include "../../type.h"
#include "Track.h"
using std::vector;

/**
 * Record, analyse, and interpret movements generated by IR blobs.
 * Performs recording, gensture matching, and movement analysis
 *	and maps them to controls for the audio namespace.
 * @author EB
 * @author SA
 * @version 1.0
 * @see audio
 */
namespace interpreter
{

/**
 * Holds a Recording of IR blob information from the parser.
 * Contains a snapshot Recording from the Recorder at the time of the call
 * @author EB
 * @version 1.0
 */
class Recording
{

///////////////////////////////////////////////////////////////////////////////
// friends
//
	/**
	 * Be friends with Recorder so that Recorder can create instances of this
	 * @author EB
	 * @version 1.0
	 */
	friend				class Recorder;

///////////////////////////////////////////////////////////////////////////////
// queries
//
public:
	/**
	 * Returns the number of tracks.
	 * @return The number of tracks held by this recorder
	 * @author EB
	 * @version 1.0
	 */
	uint				length						(void)	const;
	/**
	 * Returns the indexed Track.
	 * Index should be in the range (0..length()-1)
	 * @param index Index of track to return, from 0 to length() - 1
	 * @return Indexed track. If Index is out of range, 0 is returned
	 * @warning Each Recording returned from the Recorder could have tracks
	 *	in different indexes. Don't assume that if IR blob id 0 was indexed
	 *	at 0 one time, it will be at 0 another.
	 * @author EB
	 * @version 1.0
	 * @pre index >= 0 && index < length();
	 * @post /result != 0;
	 */
	Track const * const	operator []
						(	uint const				index
						)	const;

///////////////////////////////////////////////////////////////////////////////
// friend *tor
//
private:
	/**
	 * Construct a Recording.
	 * Containing a snapshot of the Recorder at the time it was created. This
	 *	is private except to friend Recorder which creates the object
	 * @param tracks The state of the Recorder's track
	 * @author EB
	 * @version 1.0
	 * @post this->length() == length;
	 */
						Recording
						(	vector<Track*> const &	tracks
						);
	/**
	 * Destruct a Recording.
	 * Called by Recorder::erase(Recording*)
	 * @author EB
	 * @version 1.0
	 */
						~Recording					(void);

///////////////////////////////////////////////////////////////////////////////
// fields
//
private:
	/**
	 * Contains a copy of the Recorders track at the time the Recording was
	 *	generated
	 * @author EB
	 * @version 1.0
	 */
	vector<Track*>		_tracks;

};

///////////////////////////////////////////////////////////////////////////////

inline uint Recording::length(void) const
{	return _tracks.size();
}

inline Track const * const Recording::operator []
(	uint const	index
)	const
{	return _tracks[index];
}

}

#endif
